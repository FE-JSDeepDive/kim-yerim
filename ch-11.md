# 원시 값과 객체의 비교

값: 변수에 저장된 데이터로서 표현식이 평가되어 생성된 결과

- 원시 타입의 값은 **변경 불가능**하지만 객체(참조) 타입의 값은 **변경 가능**한 값이다.
- 원시 값을 변수에 할당하면 변수에는 실제값이 저장되지만 객체를 변수에 할당하면 변수에 참조 값이 저장된다.
- 원시 값을 갖는 변수를 다른 변수에 할당하면 원시 값이 복사되어 `값에 의한 전달(pass by value)`이 발생한다. 그러나 객체를 가리키는 변수를 다른 변수에 할당하면 원본의 참조 값이 복사되어 `참조에 의한 전달(pass by reference)`가 발생한다.

## 원시 값

### 변경 불가능한 값 (immutable value)

읽기 전용 값으로 메모리 공간 내의 값을 변경할 수 없다.
<br>이를 불변성이라 하며 원시 값을 갖는 변수의 값을 변경하기 위해서는 새로운 메모리 공간을 확보하고 재할당할 값을 저장한 후, 변수가 참조하던 메모리 공간의 주소를 변경해야 한다. (재할당)
<br>따라서 이 특성은 데이터의 신뢰성을 보장한다.

### 문자열과 불변성

문자열은 다른 원시 값과 달리 몇 개의 문자로 이루어졌느냐에 따라 필요한 메모리 공간의 크기가 결정된다.

문자열은 유사 배열 객체이면서 이터러블이므로 배열과 유사하게 인덱스를 사용해 각 문자에 접근할 수 있다.

```
var str = 'string';

console.log(str[0]); // s

console.log(str.length); // 6

console.log(str.toUpperCase()); // STRING
```

문자열은 변경 불가능한 값이기 때문에 배열처럼 일부 문자열을 변경하려 해도 변경되지 않는다.

### 값에 의한 전달

변수에 원시 값을 갖는 변수를 할당하면 할당받는 변수에는 할당되는 변수의 원시 값이 복사한 메모리 주소를 전달한다.
<br>할당받는 변수와 할당되는 변수의 값은 **다른 메모리 공간에 저장된 별개의 값**이다.

## 객체

객체는 프로퍼티를 동적으로 추가하고 삭제할 수 있어 확보해야 할 메모리 공간의 크기를 사전에 정해둘 수 없다.

### 변경 가능한 값 (mutable value)

객체를 할당한 변수가 기억하는 메모리 주소를 통해 메모리 고악ㄴ에 접근하면 `참조 값(reference value)`에 접근할 수 있다.

객체는 **재할당 없이도 객체를 직접 변경 가능**
<br>재할당 없이 프로퍼티를 동적으로 추가할 수도 있고 프로퍼티 값을 객신할 수도 있으며 프로퍼티 자체를 삭제시킬 수도 있다.
<br>이때 객체를 할당한 변수의 참조 값은 변경되지 않는다.

#### 부작용

여러 개의 식별자가 하나의 객체를 공유할 수 있다.

#### 얉은 복사와 깊은 복사

복사되어 생성된 객체는 원본과는 다른 객체다.

- 얉은 복사: 한 단계까지만 복사. 객체에 중첩되어 있는 객체의 경우 참조 값을 복사. 객체를 할당한 변수를 다른 변수에 할당하는 것.
- 깊은 복사: 객체에 중첩되어 있는 객체까지 모두 복사. 객체에 중첩되어 있는 객체까지 모두 복사. 원시값을 할당한 변수를 다른 변수에 할당하는 것.

```
const o = { x: { y: 1 } };

// 얉은 복사
const c1 = { ...o };
console.log(c1 === o); // false
console.log(c1.x === o.x); // true

// lodash의 cloneDeep을 사용한 깊은 복사
const _ = require('ladash');

const c2 = _.cloneDeep(o);
console.log(c2 === o); // false
console.log(c2.x === o.x); // false
```

### 참조에 의한 전달

객체를 가리키는 변수를 다른 변수에 할당하면 **원본의 참조 값이 복사되어 전달되는 것**을 말한다.
<br>두 변수는 저장된 메모리 주소는 다르지만 동일한 참조 값을 공유한다.
<br>따라서 어느 한쪽에서 객체를 변경하면 서로 영향을 주고받는다.
